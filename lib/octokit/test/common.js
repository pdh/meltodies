// Generated by CoffeeScript 1.8.0
(function() {
  var makeTests;

  makeTests = function(assert, expect, btoa, Octokit) {
    var DEFAULT_BRANCH, IS_NODE, LONG_TIMEOUT, ORG_NAME, OTHER_HOMEPAGE, OTHER_USERNAME, REPO_HOMEPAGE, REPO_NAME, REPO_USER, SHORT_TIMEOUT, TOKEN, USERNAME, arrayContainsKey, helper1, helper2, some, trapFail;
    USERNAME = 'octokit-test';
    TOKEN = 'dca7f85a5911df8e9b7aeb4c5be8f5f50806ac49';
    ORG_NAME = 'octokit-test-org';
    REPO_USER = USERNAME;
    REPO_NAME = 'octokit-test-repo';
    REPO_HOMEPAGE = 'https:/github.com/philschatz/octokit.js';
    OTHER_HOMEPAGE = 'http://example.com';
    OTHER_USERNAME = 'octokit-test2';
    DEFAULT_BRANCH = 'master';
    LONG_TIMEOUT = 10 * 1000;
    SHORT_TIMEOUT = 5 * 1000;
    IS_NODE = !(typeof module === "undefined" || module === null);
    some = function(arr, fn) {
      var entry, _fn, _i, _len;
      _fn = function(entry) {
        if (fn(entry) === true) {
          return true;
        }
      };
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        entry = arr[_i];
        _fn(entry);
      }
      return false;
    };
    trapFail = function(promise) {
      var onError;
      onError = function(err) {
        console.error(JSON.stringify(err));
        return assert["catch"](err);
      };
      (typeof promise["catch"] === "function" ? promise["catch"](onError) : void 0) || promise.fail(onError);
      return promise;
    };
    helper1 = function(done, promise, func) {
      return trapFail(promise).then(func).then(function() {
        return done();
      });
    };
    helper2 = function(promise, func) {
      return trapFail(promise).then(func);
    };
    arrayContainsKey = function(arr, key, value) {
      return some(arr, function(entry) {
        return entry[key] === value;
      });
    };
    return describe('Octokit', function() {
      var ANOTHER_USER, BRANCH, GH, REPO, STATE, USER, itIsOk;
      this.timeout(LONG_TIMEOUT);
      GH = 'GH';
      REPO = 'REPO';
      USER = 'USER';
      BRANCH = 'BRANCH';
      ANOTHER_USER = 'ANOTHER_USER';
      STATE = {};
      itIsOk = function(obj, funcName) {
        return it("#" + funcName + "()", function(done) {
          return helper1(done, STATE[obj][funcName](), function(val) {
            return expect(val).to.be.ok;
          });
        });
      };
      before(function() {
        var options;
        options = {
          token: TOKEN,
          usePostInsteadOfPatch: true
        };
        if (IS_NODE) {
          options.useETags = false;
        }
        STATE[GH] = new Octokit(options);
        return STATE[USER] = STATE[GH].getUser();
      });
      itIsOk(GH, 'getZen');
      itIsOk(GH, 'getAllUsers');
      itIsOk(GH, 'getPublicGists');
      itIsOk(GH, 'getPublicEvents');
      describe('Repo:', function() {
        var PREV_SHA;
        this.timeout(LONG_TIMEOUT);
        PREV_SHA = null;
        before(function(done) {
          var createRepo, promise, resetRepoToFirstCommit;
          STATE[REPO] = STATE[GH].getRepo(REPO_USER, REPO_NAME);
          STATE[BRANCH] = STATE[REPO].getDefaultBranch();
          createRepo = function() {
            var options;
            console.log('BEFORE: Creating test repo');
            options = {
              description: 'Test Repository for https:/github.com/philschatz/octokit.js',
              homepage: REPO_HOMEPAGE,
              auto_init: true
            };
            return trapFail(STATE[USER].createRepo(REPO_NAME, options)).then(function() {
              console.log('BEFORE: Done Creating test repo');
              return setTimeout(done, SHORT_TIMEOUT);
            });
          };
          resetRepoToFirstCommit = function(repoInfo) {
            var findLastCommits;
            findLastCommits = function(commits, options) {
              var initialCommit, masterBranch, sha;
              console.log('BEFORE: Found commits');
              if (options != null ? options.next : void 0) {
                return trapFail(options.next()).then(findLastCommits);
              } else {
                console.log('BEFORE: Finding master branch');
                initialCommit = commits[commits.length - 1];
                sha = initialCommit.sha;
                masterBranch = repoInfo.default_branch;
                console.log('BEFORE: Found master branch');
                console.log("BEFORE: Updating " + masterBranch + " to " + sha);
                return trapFail(STATE[REPO].git.updateHead(masterBranch, sha, true)).then((function(_this) {
                  return function() {
                    console.log('BEFORE: Updated HEAD');
                    return done();
                  };
                })(this));
              }
            };
            console.log('BEFORE: Resetting test repo name and homepage');
            return trapFail(STATE[REPO].updateInfo({
              name: REPO_NAME,
              homepage: REPO_HOMEPAGE
            })).then(function() {
              console.log('BEFORE: Getting recent commits');
              return trapFail(STATE[REPO].getCommits()).then(findLastCommits);
            });
          };
          console.log('BEFORE: Checking if repo exists');
          promise = STATE[REPO].getInfo().then(function(val) {
            return resetRepoToFirstCommit(val);
          });
          return (typeof promise["catch"] === "function" ? promise["catch"](createRepo) : void 0) || promise.fail(createRepo);
        });
        describe('Initially:', function() {
          it('has one commit', function(done) {
            return trapFail(STATE[REPO].getCommits()).then(function(val) {
              expect(val).to.have.length(1);
              return done();
            });
          });
          return it('has one branch', function(done) {
            return trapFail(STATE[REPO].getBranches()).then(function(branches) {
              expect(branches).to.have.length(1);
              return done();
            });
          });
        });
        describe('Writing file(s):', function() {
          it('commits a single text file', function(done) {
            var FILE_PATH, FILE_TEXT;
            FILE_PATH = 'test.txt';
            FILE_TEXT = 'Hello there';
            return trapFail(STATE[BRANCH].write(FILE_PATH, FILE_TEXT)).then(function(sha) {
              return trapFail(STATE[BRANCH].read(FILE_PATH)).then(function(val) {
                expect(val.content).to.equal(FILE_TEXT);
                PREV_SHA = val.sha;
                return done();
              });
            });
          });
          it('removes a single file', function(done) {
            var FILE_PATH;
            FILE_PATH = 'test.txt';
            return trapFail(STATE[BRANCH].remove(FILE_PATH)).then(function() {
              return done();
            });
          });
          it('commits multiple files at once (including binary ones)', function(done) {
            var BINARY_DATA, FILE1, FILE2, contents;
            FILE1 = 'testdir/test1.txt';
            FILE2 = 'testdir/test2.txt';
            BINARY_DATA = 'Ahoy!';
            contents = {};
            contents[FILE1] = 'Hello World!';
            contents[FILE2] = {
              content: btoa(BINARY_DATA),
              isBase64: true
            };
            return trapFail(STATE[BRANCH].writeMany(contents)).then(function() {
              return trapFail(STATE[BRANCH].read(FILE1)).then(function(val) {
                expect(val.content).to.equal(contents[FILE1]);
                return trapFail(STATE[BRANCH].read(FILE2)).then(function(val) {
                  expect(val.content).to.equal(contents[FILE2].content);
                  return done();
                });
              });
            });
          });
          return it('should have created 4 commits (3 + the initial)', function(done) {
            return helper1(done, STATE[REPO].getCommits(), function(commits) {
              return expect(commits).to.have.length(4);
            });
          });
        });
        describe('Collaborators:', function() {
          it('initially should have only 1 collaborator', function(done) {
            return helper1(done, STATE[REPO].getCollaborators(), function(collaborators) {
              return expect(collaborators).to.have.length(1);
            });
          });
          it('initially the collaborator should be [USERNAME]', function(done) {
            return helper1(done, STATE[REPO].isCollaborator(USERNAME), function(canCollaborate) {
              return expect(canCollaborate).to.be["true"];
            });
          });
          it('the current user should be able to collaborate', function(done) {
            return helper1(done, STATE[REPO].canCollaborate(), function(canCollaborate) {
              return expect(canCollaborate).to.be["true"];
            });
          });
          return it('should be able to add and remove a collaborator', function(done) {
            return helper2(STATE[REPO].addCollaborator(OTHER_USERNAME), function(added) {
              expect(added).to.be["true"];
              return helper2(STATE[REPO].isCollaborator(OTHER_USERNAME), function(canCollaborate) {
                expect(canCollaborate).to.be["true"];
                return helper2(STATE[REPO].removeCollaborator(OTHER_USERNAME), function(removed) {
                  expect(removed).to.be["true"];
                  return helper1(done, STATE[REPO].isCollaborator(OTHER_USERNAME), function(canCollaborate) {
                    return expect(canCollaborate).to.be["false"];
                  });
                });
              });
            });
          });
        });
        describe('Editing Repository:', function() {
          it('initially the repository homepage should be [REPO_HOMEPAGE]', function(done) {
            return helper1(done, STATE[REPO].getInfo(), function(info) {
              return expect(info.homepage).to.equal(REPO_HOMEPAGE);
            });
          });
          it('should be able to edit the repo homepage', function(done) {
            return helper2(STATE[REPO].updateInfo({
              name: REPO_NAME,
              homepage: OTHER_HOMEPAGE
            }), function() {
              return helper1(done, STATE[REPO].getInfo(), function(info) {
                return expect(info.homepage).to.equal(OTHER_HOMEPAGE);
              });
            });
          });
          return it('changing the default branch should not explode', function(done) {
            return helper1(done, STATE[REPO].setDefaultBranch(DEFAULT_BRANCH), function(result) {
              return expect(result.default_branch).to.equal(DEFAULT_BRANCH);
            });
          });
        });
        describe('fetch organization', function() {
          return it('should be able to fetch organization info', function(done) {
            return helper1(done, STATE[GH].getOrg(ORG_NAME).getInfo(), function(info) {
              return expect(info.login).to.equal(ORG_NAME);
            });
          });
        });
        describe('Releases', function() {
          return it('should be able to get releases', function(done) {
            return helper1(done, STATE[REPO].getReleases(), function(releases) {
              return expect(releases).to.have.length(0);
            });
          });
        });
        describe('Events:', function() {
          itIsOk(REPO, 'getEvents');
          itIsOk(REPO, 'getIssueEvents');
          return itIsOk(REPO, 'getNetworkEvents');
        });
        return describe('Misc:', function() {
          itIsOk(REPO, 'getHooks');
          itIsOk(REPO, 'getLanguages');
          return itIsOk(REPO, 'getInfo');
        });
      });
      return describe('Users:', function() {
        describe('Current User:', function() {
          describe('Methods for all Users:', function() {
            itIsOk(USER, 'getInfo');
            itIsOk(USER, 'getRepos');
            itIsOk(USER, 'getOrgs');
            itIsOk(USER, 'getGists');
            itIsOk(USER, 'getFollowers');
            itIsOk(USER, 'getFollowing');
            return itIsOk(USER, 'getReceivedEvents');
          });
          return describe('Methods only for authenticated user:', function() {
            itIsOk(USER, 'getGists');
            itIsOk(USER, 'getEmails');
            return itIsOk(USER, 'getReceivedEvents');
          });
        });
        return describe('Another User:', function() {
          before(function() {
            return STATE[ANOTHER_USER] = STATE[GH].getUser(OTHER_USERNAME);
          });
          itIsOk(ANOTHER_USER, 'getInfo');
          itIsOk(ANOTHER_USER, 'getRepos');
          itIsOk(ANOTHER_USER, 'getOrgs');
          itIsOk(ANOTHER_USER, 'getGists');
          itIsOk(ANOTHER_USER, 'getFollowers');
          itIsOk(ANOTHER_USER, 'getFollowing');
          itIsOk(ANOTHER_USER, 'getPublicKeys');
          itIsOk(ANOTHER_USER, 'getReceivedEvents');
          return itIsOk(ANOTHER_USER, 'getEvents');
        });
      });
    });
  };

  if (typeof exports !== "undefined" && exports !== null) {
    exports.makeTests = makeTests;
  } else {
    this.makeTests = makeTests;
  }

}).call(this);
